"""
    StepInterface IMPLEMENTATION CLASS DEFINITION for generating from a va scan vulnerability report
    an enhanced processed vulnerability .xlsx file, including additional information.
    Each step implementation class do a single specific operation.
    The order in which step implementation classes are called is , for some steps, mandatory and
    driven by the main in va_enrich_report_generator.py file
"""

from typing import Tuple

import lib.utility_lib as Util
import pandas as pd

from step_definition.step_interface import StepInterface
from step_definition.step_data import StepData

from shared_var_and_constant import TEAM_NAME_NOT_IN_JIRA, RA_NOT_IN_JIRA


class StepRemoveTeamNameAndRaNotAvailableOnJira(StepInterface):
    """ This class moves rows where Team Name and RA are not available on Jira
        from the VA report dataframe to the Unprocessed dataframe

    Attributes:
        __jira_table_df (pd.DataFrame): (instance attribute) The JIRA df including JIRA allowed
                                        Team Name and RA

    """

    @Util.strict_types
    def __init__(self, step_data: StepData, jira_table_df: pd.DataFrame):
        super().__init__(step_data)
        self.__jira_table_df = jira_table_df

    @Util.strict_types
    def __step__remove_team_name_not_in_jira(self, va_df: pd.DataFrame,
                                           jira_df: pd.DataFrame) \
            -> Tuple[pd.DataFrame, pd.DataFrame]:
        """
        Remove rows with Team name not available on Jira
        Args:
            va_df: va report dataframe
            jira_df: Jira dataframe

        Returns: va report dataframe without Team name not available on Jira and
        unprocessed dataframe with Team name not available on Jira
        """
        va_team_list = va_df['Team'].dropna().drop_duplicates().sort_values()
        self._logger.info("'Team' list on Vulnerability report: \n\t- %s\n",
                    "\n\t- ".join(va_team_list.values))

        team_found_df = va_df[va_df['Team'].isin(jira_df['Team'])]
        rows_to_remove_df = va_df[~va_df['Team'].isin(jira_df['Team'])]

        if not rows_to_remove_df.empty:
            message = \
                "The following #" + str(len(rows_to_remove_df['Team'].unique())) \
                + " 'Team' on the Vulnerability report, are not available in Jira:"
            for item in rows_to_remove_df['Team'].unique():
                message += "\n\t- " + item
            self._logger.info("%s\n", message)
            self._logger.info(
                "Removed #%d row on Vulnerability report, due to 'Team' name not "
                "available in Jira:\n%s\n",
                len(rows_to_remove_df), rows_to_remove_df
            )
        else:
            self._logger.info(
                "All the 'Team' name on the Vulnerability report are present "
                "in Jira."
            )

        return team_found_df, rows_to_remove_df

    @Util.strict_types
    def __step__remove_ra_not_in_jira(self, va_df: pd.DataFrame,
                                    jira_df: pd.DataFrame) \
            -> Tuple[pd.DataFrame, pd.DataFrame]:
        """
        Remove rows with RA not available on Jira
        Args:
            va_df: va report dataframe
            jira_df: Jira dataframe

        Returns: va report dataframe without RA not available on Jira and
        unprocessed dataframe with RA not available on Jira
        """
        va_ra_list = va_df['RA'].dropna().drop_duplicates().sort_values()
        self._logger.info("'RA' list on Vulnerability report: \n\t- %s\n",
                    "\n\t- ".join(va_ra_list.values))

        ra_found_df = va_df[va_df['RA'].isin(jira_df['RA'])]
        rows_to_remove_df = va_df[~va_df['RA'].isin(jira_df['RA'])]

        if not rows_to_remove_df.empty:
            message = \
                "The following #" + str(len(rows_to_remove_df['RA'].unique())) \
                + " 'RA' on the Vulnerability report, are not available in Jira:"
            for item in rows_to_remove_df['RA'].unique():
                message += "\n\t- " + item
            self._logger.info("%s\n", message)
            self._logger.info(
                "Removed #%d row on Vulnerability report, due to 'RA' not "
                "available in Jira:\n%s\n",
                len(rows_to_remove_df), rows_to_remove_df
            )
        else:
            self._logger.info(
                "All the 'RA' on the Vulnerability report are present in Jira."
            )
        return ra_found_df, rows_to_remove_df

    def execute(self):
        """
        Base class abstract method implementation.
        Execute the operation expected for this step class
        """
        self._logger.info("STEP %d: Removes 'VA report' rows where Team Name and/or RA are not available on Jira "
                    "and moves them to the 'Unprocessed' file", self._step_num)
        va_report_df = self._step_data.get_curr_va_report_df

        # Team name management
        va_report_team_name_in_jira, team_name_not_in_jira_df = \
            self.__step__remove_team_name_not_in_jira(va_report_df, self.__jira_table_df)

        self._step_data.add_to_unprocessed_dict(team_name_not_in_jira_df, TEAM_NAME_NOT_IN_JIRA)

        # Ra management
        va_report_ra_in_jira, ra_not_in_jira_df = \
            self.__step__remove_ra_not_in_jira(va_report_team_name_in_jira, self.__jira_table_df)

        self._step_data.set_va_report_data(va_report_ra_in_jira)
        self._step_data.add_to_unprocessed_dict(ra_not_in_jira_df, RA_NOT_IN_JIRA)

        self._logger.debug("STARTING TABLE LEN = %d, END TABLE LEN = %d",
                    len(va_report_df), len(va_report_team_name_in_jira))

    def validate(self) -> bool:
        """
        Base class overriden method.
        Validate the operation expected for this step class
        """
        self._logger.info("Validating STEP %d .........", self._step_num)
        new_df, prev_df = self.get_curr_prev_va_report_df()

        total_removed_row = \
            len(self._step_data.get_unprocessed_dict(TEAM_NAME_NOT_IN_JIRA)) + \
            len(self._step_data.get_unprocessed_dict(RA_NOT_IN_JIRA))

        if len(new_df) != (len(prev_df) - total_removed_row):
            self._logger.error("New table len %d doesn't match the original table len %d ... EXITING",
                         len(new_df), len(prev_df))
            return False
        return True
