"""
    StepInterface IMPLEMENTATION CLASS DEFINITION for generating from a va scan vulnerability report
    an enhanced processed vulnerability .xlsx file, including additional information.
    Each step implementation class do a single specific operation.
    The order in which step implementation classes are called is , for some steps, mandatory and
    driven by the main in va_enrich_report_generator.py file
"""
import os

import numpy as np

import lib.utility_lib as Util
import pandas as pd

from step_definition.step_interface import StepInterface
from step_definition.step_data import StepData
# from check_cxp_sg_on_unprocessed import check_cxp_on_unprocessed, check_sg_on_unprocessed


class StepCheckUnprocessedCxpSg(StepInterface):
    """ This class check in the 'Unprocessed' file which 'CXP' and 'SG' are
        missing in the CXP/SG db table file

    Attributes:
        __sg_mapping_table (pd.DataFrame): (instance attribute) The SG_mapping df matching
               SG/image_name with teams/RA/CNA
        __cxp_table (pd.DataFrame): (instance attribute) The CXP_table df matching CXP
               with teams/RA/CNA
        __unproc_file (pd.DataFrame): (instance attribute) The unprocessed df to look for SG/CXP
               not present in SG/CXP db table files

    """

    UNPROCESSED_COLUMN_CXP_FROM_RPM = "CXP from Rpm Name"
    UNPROCESSED_COLUMN_REASON = "Reason"
    UNPROCESSED_COLUMN_IMAGE_NAME = "Image Name"
    UNPROCESSED_REASON_VALUE = "Unknown/missing responsible Team and/or RA"

    CXP_COLUMN_CXP = "CXP"
    SG_COLUMN_SG = "SG List from VA Scan"

    @Util.strict_types
    def __check_cxp_on_unprocessed(self, uv_df: pd.DataFrame, cxp_df: pd.DataFrame) -> str:
        """
        Check which CXP in the 'Unprocessed' report file are not defined in the
        CXP table.

        Args:
            uv_df: unprocessed dataframe
            cxp_df: CXP dataframe

        Returns:
            The check result in string format
        """
        not_found_cxp_df = \
            uv_df[~uv_df[self.UNPROCESSED_COLUMN_CXP_FROM_RPM]
            .isin(cxp_df[self.CXP_COLUMN_CXP])]
        not_found_cxp_list = \
            not_found_cxp_df[self.UNPROCESSED_COLUMN_CXP_FROM_RPM].dropna().unique()

        if len(not_found_cxp_list):
            result_cxp_check = \
                "The following CXP items (#" + str(len(not_found_cxp_list)) + ") " \
                + "are not present in the CXP table:\n"
            for item in np.sort(not_found_cxp_list):
                result_cxp_check += "\t- " + item + "\n"
        else:
            result_cxp_check = "All the CXPs code are found!"

        return result_cxp_check

    @Util.strict_types
    def __check_sg_on_unprocessed(self, uv_df: pd.DataFrame, sg_df: pd.DataFrame) -> str:
        """
        Check which SG of the 'Unprocessed' file are not defined in the
        SG table file

        Args:
            uv_df: unprocessed dataframe
            sg_df: SG dataframe

        Returns:
            The check result in string format
        """
        unknown_sg_df = \
            uv_df.loc[uv_df[self.UNPROCESSED_COLUMN_REASON] == self.UNPROCESSED_REASON_VALUE]
        not_found_sg_df = unknown_sg_df[
            ~unknown_sg_df[self.UNPROCESSED_COLUMN_IMAGE_NAME].isin(sg_df[self.SG_COLUMN_SG])
        ]
        not_found_sg_list = \
            not_found_sg_df[self.UNPROCESSED_COLUMN_IMAGE_NAME].dropna().unique()

        if len(not_found_sg_list):
            result_sg_check = \
                "The following SG items (#" + str(len(not_found_sg_list)) + ") " \
                + "are not present in the SG table:\n"
            for item in np.sort(not_found_sg_list):
                result_sg_check += "\t- " + item + "\n"
        else:
            result_sg_check = "All the SGs are found!"

        return result_sg_check

    @Util.strict_types
    def __init__(self, step_data: StepData, sg_mapping_table: pd.DataFrame, cxp_table: pd.DataFrame,
                 unproc_file: str):
        super().__init__(step_data)
        self.__sg_mapping_table = sg_mapping_table
        self.__cxp_table = cxp_table
        self.__unproc_file = unproc_file

    def execute(self):
        """
        Base class abstract method implementation.
        Execute the operation expected for this step class
        """
        self._logger.info("STEP %d: This class check in the 'Unprocessed' file which 'CXP' and 'SG' are missing in the "
                    "CXP/SG db table file", self._step_num)

        if not os.path.exists(self.__unproc_file):
            self._logger.info("STEP %d: Skipping check. Unprocessed file not available.", self._step_num)
        else:
            unprocessed_df = Util.get_df_from_spreadsheet_file(self.__unproc_file)
            if unprocessed_df is None:
                self._logger.error("STEP %d: Skipping check. Issue on unprocessed file.", self._step_num)
            else:
                cxp_test_result = self.__check_cxp_on_unprocessed(unprocessed_df, self.__cxp_table)
                sg_test_result = self.__check_sg_on_unprocessed(unprocessed_df, self.__sg_mapping_table)
                self.__outputs = (cxp_test_result, sg_test_result)

                # Log the result
                self._logger.info("%s", cxp_test_result)
                self._logger.info("%s", sg_test_result)

        self._logger.info("STEP %d: Finished processing.", self._step_num)

    def get_execution_results(self):
        return self.__outputs
