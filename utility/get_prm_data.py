"""
This module contains the functions to download PRM data,
filter and save them to a Pandas Dataframe.
When invoked as a main script, the Dataframe is saved to an Excel file.
"""
import sys
import os
from typing import Optional
import logging.config
import argparse
import csv
import json
import requests
import pandas as pd

THIS_SCRIPT_DIR = os.path.abspath(os.path.dirname(__file__))
sys.path.insert(0, os.path.join(THIS_SCRIPT_DIR, '..'))
#pylint: disable=wrong-import-position, import-error
from python_script.lib.utility_lib import (delete_files, strict_types,
                                           get_data_from_yaml_file,
                                           check_python_and_pandas_version,
                                           write_sheet_to_excel, colour_text,
                                           MyColours)
#pylint: enable=wrong-import-position, import-error


def configure_logger_for_main() -> None:
    """
    Configure logging when invoked as script
    """
    log_formatter = logging.Formatter(
        '%(asctime)s - %(levelname)-8s [%(filename)s:%(lineno)-4s] %(message)s'
    )
    file_handler = logging.FileHandler(filename='get_prm_data.log', mode="w")
    file_handler.setFormatter(log_formatter)

    console_handler = logging.StreamHandler()
    console_handler.setFormatter(log_formatter)

    logging.basicConfig(encoding='utf-8',
                        level=logging.INFO,
                        handlers=[file_handler, console_handler])


# create logger
if __name__ == "__main__":
    configure_logger_for_main()
else:
    logging.config.dictConfig(
        get_data_from_yaml_file(
            os.path.join(THIS_SCRIPT_DIR, '../logging.yaml')))

logger = logging.getLogger()


@strict_types
def exit_if_file_exists(file_name: str) -> None:
    """
    Verifies that a file with the name specified by the input parameter does not exist.
    If it finds one, the script it exits with an error code.

    Args:
        file_name: the string containing the full name of a file.
    """
    if os.path.isfile(file_name):
        logger.error(
            colour_text(
                MyColours.RED, f'Output file "{file_name}" already exists, '
                'please remove it or change its name.'))
        sys.exit(1)


@strict_types
def validate_excel_file_name(file_name: str) -> str:
    """
    Checks that the given file name is a valid Excel file name

    Args:
        file_name: the string containing the full name of a file.

    Returns:
        the same file name with lowercase extension if it is a valid name,
        otherwise it raises an exception
    """
    path, ext = os.path.splitext(file_name)
    if path and ext.lower().endswith('.xlsx'):
        return path + ext.lower()
    raise argparse.ArgumentTypeError(
        f"not a valid Excel file name: {file_name}")


@strict_types
def get_service_group_name(path: str) -> str:
    """
    Gets from path string a Service Group name in case it refers to a Service Group.

    Args:
        path: the string which could refer to a Service Group.

    Returns:
        the extracted Service Group name, or NaN if no Service Group is found.
    """
    svc_group_presence_marker = 'com.ericsson.oss.containerisation/'
    suffix_to_be_removed = '.git'
    svc_group_name = ""

    repo_path = str(path)
    if svc_group_presence_marker in repo_path:
        svc_group_name = repo_path.rsplit(svc_group_presence_marker,
                                          maxsplit=1)[-1]

    return svc_group_name.removesuffix(suffix_to_be_removed)


@strict_types
def save_prm_data(prm_json_file_name: str) -> None:
    """
    Queries PRM server by REST API and saves its attributes to a json file.

    Args:
        prm_json_file_name: string containing the full name of the json file.
    """

    logger.info("Downloading PRM data from server.")

    PRM_API_URL = 'https://pdu-oss-tools1.seli.wh.rnd.internal.ericsson.com' \
                  + '/product-role-matrix/api/csa'

    headers = {'Accept': 'application/json'}

    try:
        response = requests.get(PRM_API_URL, headers=headers, timeout=10)
    except requests.exceptions.RequestException as exc:
        logger.error(
            colour_text(
                MyColours.RED,
                'Exception caught while getting data from PRM server:\n%s'),
            exc)
        return

    if response.status_code != 200:
        logger.error(
            colour_text(
                MyColours.RED,
                f'Wrong response status code received from PRM server: {response.status_code}.'
            ))
        return

    try:
        fd_json = open(prm_json_file_name, "wb")
    except OSError as exc:
        logger.error(
            colour_text(
                MyColours.RED,
                f'Could not open/write file {prm_json_file_name}:\n{exc}'))
        return

    with fd_json:
        for chunk in response.iter_content(None):
            fd_json.write(chunk)


@strict_types
def get_cxp_data(src_json_data: list) -> list:
    """
    Walks through the JSON structure containing the downloaded PRM information and
    selects required fields associating them to each CXP.

    Args:
        src_json_data (list): the json structure representing the downloaded PRM data.

    Returns:
        list: a flat list containing the required information associated to each CXP.
    """

    cxp_data_list = []

    logging.info(
        'Walking through PRM JSON structure to extract required fields.')
    for csa in src_json_data:
        for cra in csa['cras']:
            for cna in cra['cnas']:
                for cxp in cna['cxps']:
                    cxp_data_list.append({
                        "CNA Name":
                        cna.get('name'),
                        "CNA Number":
                        cna.get('number'),
                        "associated RA":
                        cra.get('associatedRa'),
                        "CNA Resp LM":
                        cna.get('responsibleLineManager'),
                        "CNA Funct Resp":
                        cna.get('cnaFunctResp'),
                        "CNA SAR":
                        cna.get('sar'),
                        "CNA Team Name":
                        cna.get('teamName'),
                        "CXP Number":
                        cxp.get('number'),
                        "CXP Name":
                        cxp.get('name'),
                        "Ownership at CXP level":
                        cna.get('cxpOwnership'),
                        "CXP Responsible":
                        cxp.get('cxpResp'),
                        "Team Ownership at CXP level":
                        cna.get('cxpTeamOwnership'),
                        "CXP Responsible Team":
                        cxp.get('cxpRespTeam'),
                        "CXP Line Manager":
                        cxp.get('lineManager'),
                        "CXP Path":
                        cxp.get('repo'),
                        "RPM Name":
                        cxp.get('rpm')
                    })

    return cxp_data_list


@strict_types
def filter_prm_data(prm_json_file_name: str,
                    filtered_csv_file_name: str) -> None:
    """
    Takes just some fields from the full PRM data by using the jq command (invoked in a subprocess)
    and saves the selected attributes to a specified csv file.

    Args:
        prm_json_file_name: string containing the full name of the input PRM json file.
        filtered_csv_file_name: string containing the full name of the filtered csv file.
    """

    logger.info("Extracting required fields from downloaded data.")

    try:
        prm_json_file = open(prm_json_file_name, 'r', encoding="utf-8")
    except OSError as exc:
        logger.error(
            colour_text(
                MyColours.RED,
                f'ERROR: Could not open/read file {prm_json_file_name}:\n{exc}'
            ))
        return

    json_data = []
    with prm_json_file:
        try:
            json_data = json.load(prm_json_file)
        except json.JSONDecodeError as exc:
            logger.error(
                colour_text(
                    MyColours.RED,
                    f'Exception caught while reading JSON content from file {prm_json_file_name}:\n{exc}'
                ))
            return

    if not isinstance(json_data, list) or len(json_data) == 0:
        logger.error(
            colour_text(MyColours.RED, "Unexpected decoded JSON content."))
        return

    filtered_json = get_cxp_data(json_data)
    headers = filtered_json[0].keys()

    try:
        filtered_csv_file = open(filtered_csv_file_name, 'w', encoding="utf-8")
    except OSError as exc:
        logger.error(
            colour_text(
                MyColours.RED,
                f'Could not open/write file {filtered_csv_file_name}:\n{exc}',
            ))
        return

    with filtered_csv_file:
        separator = ','
        quote = '"'
        writer = csv.DictWriter(filtered_csv_file,
                                fieldnames=headers,
                                delimiter=separator,
                                quotechar=quote,
                                quoting=csv.QUOTE_NONNUMERIC,
                                lineterminator="\n")

        writer.writeheader()
        writer.writerows(filtered_json)


@strict_types
def create_report_file(prm_dataframe: pd.DataFrame,
                       report_file_name: str) -> None:
    """
    Creates the final Excel report file.

    Args:
        prm_dataframe: the Dataframe containing the filtered PRM information.
        report_file_name: string containing the full name of the Excel report.
    """

    logger.info("Creating the final report file.")

    try:
        write_sheet_to_excel(report_file_name, prm_dataframe,
                             'Product Role Matrix', True)
        logger.info("PRM data successfully saved to file %s", report_file_name)

    except Exception as exc:
        logger.error(
            colour_text(
                MyColours.RED,
                f'Exception caught during report creation to file {report_file_name}:\n{exc}'
            ))


@strict_types
def adjust_prm_dataframe(prm_dataframe: pd.DataFrame) -> pd.DataFrame:
    """
    Makes some adaptations to the PRM dataframe to ease its management

    Args:
        prm_dataframe: the Dataframe containing the required PRM information.
    """
    # replace all "non-breaking space" characters with simple spaces
    prm_dataframe = prm_dataframe.replace('\xa0', ' ', regex=True)
    prm_dataframe.fillna("", inplace=True)
    prm_dataframe['Ownership at CXP level'] = prm_dataframe[
        'Ownership at CXP level'].astype('bool')
    prm_dataframe['Team Ownership at CXP level'] = prm_dataframe[
        'Team Ownership at CXP level'].astype('bool')
    prm_dataframe['Service Group'] = prm_dataframe['CXP Path'].apply(
        get_service_group_name)

    return prm_dataframe


@strict_types
def handle_get_prm() -> Optional[pd.DataFrame]:
    """
    Creates a Dataframe containing the required information
    from the PRM (Product Role Matrix).

    Returns:
        a Dataframe containing the required PRM information
        or None in case of error
    """

    logger.info("Starting management of PRM data.")

    prm_files_working_dir = os.path.join(
        os.path.dirname(os.path.realpath(__file__)), '..',
        'generated_support_tables')
    os.makedirs(prm_files_working_dir, exist_ok=True)

    prm_json_file_name = os.path.join(prm_files_working_dir, 'curl_prm.json')
    filtered_prm_csv_file_name = os.path.join(prm_files_working_dir,
                                              'filtered_prm.csv')

    delete_files(prm_json_file_name, filtered_prm_csv_file_name)

    prm_df = None

    save_prm_data(prm_json_file_name)

    if os.path.isfile(prm_json_file_name):
        filter_prm_data(prm_json_file_name, filtered_prm_csv_file_name)

        if os.path.isfile(filtered_prm_csv_file_name):
            prm_df = pd.read_csv(filtered_prm_csv_file_name)
            prm_df = adjust_prm_dataframe(prm_df)

    if prm_df is None:
        logger.error(
            colour_text(
                MyColours.RED,
                "An error occurred while handling PRM data. Due to this, an empty dataframe will be returned."
            ))
    return prm_df


def main():
    """
    This function is invoked when launched as standalone script.
    It downloads the PRM database, keeps just the required fields and generates
    a Dataframe that will be eventually saved to an Excel file.
    """

    parser = argparse.ArgumentParser(
        description=
        "Gets a subset of data from PRM and saves them to an Excel file")

    parser.add_argument(
        "prm_report_file_name",
        type=validate_excel_file_name,
        help=
        "The full name of the Excel file that shall contain the required PRM information."
    )

    args = parser.parse_args()

    exit_if_file_exists(args.prm_report_file_name)

    check_python_and_pandas_version(str(sys.version_info.major), "3",
                                    str(pd.__version__), "2")
    prm_df = handle_get_prm()

    if prm_df is not None:
        create_report_file(prm_df, args.prm_report_file_name)
    else:
        logger.error(
            colour_text(
                MyColours.RED,
                'Some error occurred during program execution, no PRM report file has been created.'
            ))


if __name__ == "__main__":
    main()
