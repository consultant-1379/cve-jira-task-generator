"""
check_prm_data.py

Check data coming from Product Release Matrix and produces both a report and a table
with valid items for future consuming by cve scripts

Usage:
python3.10 utility/check_prm_data.py

    Related keys in config_properties.yml:
        update_cxp_table_with_prm_data
        cxp_table_updated_report
        cxp_table_updated_report_text_file
        prm_report
        prm_report_text_file

    Outputs:
    in folder db_input_tables:
        CXP_Table.csv          if CXP Table is present, CXP Table is updated with PRM valid items and info
                               according to key "update_cxp_table_with_prm_data" in config_properties.yml

    in folder log:
        PRM_report_yy-mm-dd-hh_mm_ss.xlsx     report with the result of checks on PRM data (and on optional tables)
        PRM_report_yy-mm-dd-hh_mm_ss.txt      just a summary of report, as text file

        CXP_Table_updated_report_yy-mm-dd-hh_mm_ss.xlsx  report with result of CXP Table updating
        CXP_Table_updated_report_yy-mm-dd-hh_mm_ss.txt  just a summary of report, as text file

    in folder generated_support_tables:
        PRM_issues_yy-mm-dd-hh_mm_ss.xlsx     subset of discarded items in PRM_report (i.e. without 3pp FOSS/Commercial)

Dependencies:
   (mandatory)  Team Inventory Table (check key "team_inv_table" in config_properties.yml)
   (mandatory)  CXP Table            (check key "cxp_table" in config_properties.yml)
   (mandatory)  SG Mapping Table     (check key "sg_mapping_table" in config_properties.yml)

"""
import sys
import os
import re
import logging.config
from datetime import datetime
from time import time
from typing import Tuple, Union
import numpy as np
import pandas as pd
import get_prm_data as prm

sys.path.insert(0,
                os.path.join(os.path.abspath(os.path.dirname(__file__)), '..'))
#pylint: disable=wrong-import-position, import-error
from python_script.get_team_inventory_data import get_team_inventory_as_dataframe
import python_script.lib.utility_lib as Util
#pylint: enable=wrong-import-position, import-error

# Constants
LEFT_ALIGN = "{0:<52}"
SPACE = ' '
RIGHT = 1
NEW_LINE = " " * 25 + "\n"
TO_BE_FILLED = "<not updated>"
EXTRACT_RPM_CXP_REGEX = '_(CXP\\d+):'
CXP_TABLE_FORECAST_TITLE = "--- Forecast for CXP Table update ---"
CXP_TABLE_UPDATE_TITLE = "--- Summary for CXP Table update ---"
NOTE = "*** NOTE: "
NO_CHANGES_TO_APPLY = "Current CXP_Table is up to date, no changes to apply"
FRAME_HEADER_FOR_UPDATE = [[LEFT_ALIGN.format(" "), ""], [LEFT_ALIGN.format(CXP_TABLE_UPDATE_TITLE), ""]]
FRAME_NO_CHANGES_TO_APPLY = [[LEFT_ALIGN.format(NO_CHANGES_TO_APPLY), ""]]
FRAME_SEE_CXP_REPORT_FILE = [[LEFT_ALIGN.format("CXP_Table has been updated."), ""],
                             [LEFT_ALIGN.format("See related CXP Table report files for details."), ""]]
PATH_TO_CXP_FILE = 'path_2_rpm_associations.yml'

# From configuration file
top_dir = os.path.dirname(os.path.abspath(os.path.dirname(__file__)))
config_property_file = os.path.join(top_dir, 'config_properties.yml')
dict_from_config_file = Util.config_file_to_dictionary(config_property_file, 'csv_generator_properties')
output_dir_for_report = top_dir + '/generated_support_tables/'
prm_issues = output_dir_for_report + "PRM_issues.xlsx"
prm_report = Util.get_file_from_dictionary(dict_from_config_file, 'prm_report')
prm_report_text_file = Util.get_file_from_dictionary(dict_from_config_file, 'prm_report_text_file')
va_report_filename = Util.get_file_from_dictionary(dict_from_config_file, 'va_report')
va_report_base_image_filename = Util.get_file_from_dictionary(dict_from_config_file, 'base_image')
dict_from_path_2_rpm_file = Util.config_file_to_dictionary(PATH_TO_CXP_FILE, 'path_2_rpm_associations')
cxp_table_updated_report = Util.get_file_from_dictionary(dict_from_config_file, 'cxp_table_updated_report')
cxp_table_updated_text_file = Util.get_file_from_dictionary(dict_from_config_file, 'cxp_table_updated_report_text_file')
update_cxp_table_with_prm_data = dict_from_config_file['update_cxp_table_with_prm_data']

# create logger
logging.config.dictConfig(Util.get_data_from_yaml_file('logging.yaml'))
logger = logging.getLogger("check_prm_data")

# ----------------------------------------------------------------------------------------------------------------------
# ------------------------   COMMON LIBRARY for check_prm_data.py and cve scripts  --------------------------------------
# ----------------------------------------------------------------------------------------------------------------------
@Util.strict_types
def write_prm_summary_report(summary_filename: str, summary: str):
    with open(summary_filename, 'w', encoding='UTF-8') as prm_report_text_fd:
        prm_report_text_fd.write(summary)


@Util.strict_types
def write_updated_cxp_table_report_file(suffix: str,
                                        updated_cxp_table_summary: pd.DataFrame,
                                        updated_cxp_table: pd.DataFrame):
    df_list = [updated_cxp_table_summary, updated_cxp_table]
    sheet_name_list = ['Summary', 'CXP Table updated']
    sheet_header_list = [False, True]

    Util.write_sheets_to_excel(build_filename(cxp_table_updated_report, suffix), df_list, sheet_name_list,
                               sheet_header_list)
    logger.info("Generated CXP Table Updated report file: {}".format(build_filename(cxp_table_updated_report, suffix)))


@Util.strict_types
def check_and_apply_prm_data(is_update_cxp_table: bool = False, show_summary: bool = True, suffix: str = "",
                             write_issues: bool = False) -> bool:
    # Check if the Team Inventory file is already present. If not download it
    if not os.path.isfile(dict_from_config_file['team_inv_table']):
        logger.info("Team inventory file is not available! Downloading ...")
        ti_df = get_team_inventory_as_dataframe()
        ti_df.to_csv(dict_from_config_file['team_inv_table'], index=False)
        logger.info("Team inventory file download complete!")

    # Load Team Inventory Table and CXP Table
    team_inv_df, cxp_df, sg_mapping_table_df, va_report_df = load_input_tables()
    # Read PRM raw data from PRM database
    prm_df = prm.handle_get_prm()

    if team_inv_df is not None and prm_df is not None and cxp_df is not None:
        # Save original PRM data file
        prm_df.to_csv(dict_from_config_file['prm_table'], index=False)
        logger.info("Saved PRM data to file: %s", dict_from_config_file['prm_table'])

        prm_df = check_prm(prm_df, team_inv_df)
        # Check on CXP Table to find the 'CXP number' of CXP Table also present in PRM
        cxp_table_checked_df, prm_df = update_cxp_and_prm_df(cxp_df, prm_df)
        # Check on SG Mapping Table to find SG of SG Mapping Table missing in PRM
        sg_missing_df = check_on_sg_mapping_table(sg_mapping_table_df, prm_df)
        # Build a new CXP Table updated with PRM valid data for forecast or update
        enhanced_cxp_df = create_enhanced_cxp_table_df(cxp_table_checked_df, get_valid_items(prm_df))
        # Optional check on VA Report to find the 'CXP number' of VA report also present in PRM and in CXP Table
        items_added_from_prm, resp_team_updated = check_update_of_cxp_table(enhanced_cxp_df)
        cxp_table_update_with_changes = (items_added_from_prm > 0) or (resp_team_updated > 0)
        table_for_check_on_va_report = enhanced_cxp_df if is_update_cxp_table and cxp_table_update_with_changes \
            else cxp_table_checked_df
        va_report_df, _, _ = check_on_va_report(va_report_df, table_for_check_on_va_report, prm_df)

        summary_for_updated_cxp_table = []
        if is_update_cxp_table:
            forecast_cxp_df = pd.DataFrame()
            summary_for_updated_cxp_table = create_summary_for_enhanced_cxp_table(enhanced_cxp_df, CXP_TABLE_UPDATE_TITLE)
            if cxp_table_update_with_changes:
                summary_for_forecast_cxp_table = FRAME_SEE_CXP_REPORT_FILE
                cxp_table_checked_df = pd.DataFrame()
            else:
                summary_for_forecast_cxp_table = FRAME_NO_CHANGES_TO_APPLY
            logger.info(NOTE + pd.DataFrame(summary_for_forecast_cxp_table).to_string(index=False, header=False)
                        .replace(NEW_LINE, ""))
            summary_for_forecast_cxp_table = FRAME_HEADER_FOR_UPDATE + summary_for_forecast_cxp_table
        else:
            forecast_cxp_df = enhanced_cxp_df.copy()
            summary_for_forecast_cxp_table = create_summary_for_enhanced_cxp_table(forecast_cxp_df, CXP_TABLE_FORECAST_TITLE)
            if not cxp_table_update_with_changes:
                forecast_cxp_df = pd.DataFrame()

        summary_df = pd.DataFrame(summary_for_prm(prm_df) +
                                  summary_for_sg_mapping_table(sg_mapping_table_df, sg_missing_df) +
                                  summary_for_va_report(va_report_df, prm_df) +
                                  summary_for_cxp_table(cxp_table_checked_df) +
                                  summary_for_forecast_cxp_table)

        if show_summary:
            print_step("SUMMARY")
            print(summary_df.to_string(index=False, header=False))
            print_step("=")

        # Files creation for PRM global report and enhanced CXP Table
        # print_step("GENERATING PRM REPORT")
        write_prm_report_file(suffix, summary_df, prm_df, cxp_table_checked_df, sg_missing=sg_missing_df,
                              va_report=va_report_df, forecast_cxp_table=forecast_cxp_df)
        if is_update_cxp_table and cxp_table_update_with_changes:
            write_updated_cxp_table_report_file(suffix, pd.DataFrame(summary_for_updated_cxp_table), enhanced_cxp_df)
            write_prm_summary_report(build_filename(cxp_table_updated_text_file, suffix),
                                     pd.DataFrame(summary_for_updated_cxp_table).to_string(index=False, header=False))
            write_enhanced_cxp_table_file(enhanced_cxp_df)
        else:
            logger.info("Remove old CXP updated report files")
            Util.delete_files(cxp_table_updated_report, cxp_table_updated_text_file)

        write_prm_summary_report(build_filename(prm_report_text_file, suffix),
                                 summary_df.to_string(index=False, header=False))
        logger.info("Generated PRM text report file: %s", build_filename(prm_report_text_file, suffix))

        if write_issues:
            discarded_df = get_discarded_items(prm_df)
            write_prm_issues_file(suffix, get_discarded_items_with_issues(discarded_df))

        return True

    return False


# ----------------------------------------------------------------------------------------------------------------------
# ----------------------------------------   END COMMON LIBRARY --------------------------------------------------------
# ----------------------------------------------------------------------------------------------------------------------
@Util.strict_types
def print_step(slogan: str):
    slogan_printable = "  " + slogan + "  "
    print("\x1B[3m\n========={}================\x1B[0m\n".format(slogan_printable.center(52, "=")))


@Util.strict_types
def check_team(team: str, team_list: list) -> str:
    if len(team) == 0:
        return "Missing"
    if team in team_list:
        return "OK"
    return "Not found in TI"


@Util.strict_types
def normalize_cxp_number(cxp_number: str) -> str:
    return cxp_number.replace(SPACE, '').upper()


@Util.strict_types
def check_cxp_number(cxp_number: str) -> str:
    if len(cxp_number) == 0:
        return "Missing CXP Number"
    cxp_pattern = '^CXP90\\d{5}$'
    if re.match(cxp_pattern, normalize_cxp_number(cxp_number)):
        return "OK"
    meets_3pp_criteria = [x in cxp_number for x in ["CAX", "CTX", "CXS", "CTC"]]
    if any(meets_3pp_criteria):
        return "3pp"
    return "CXP number not consistent"


@Util.strict_types
def check_and_normalize_cxp_number_in_table(input_df: pd.DataFrame) -> pd.DataFrame:
    # Check if CXP number is consistent
    input_df['Check on CXP Number'] = input_df['CXP'].apply(check_cxp_number)
    # Normalization of CXP number checked OK
    input_df.loc[input_df['Check on CXP Number'] == "OK", "CXP"] = input_df['CXP'].apply(normalize_cxp_number)
    return input_df


@Util.strict_types
def get_num_occurrences(column_values: pd.Series, substring_to_count: str) -> int:
    return (column_values.str.contains(substring_to_count)).sum()


@Util.strict_types
def add_discard_reason_column(prm_df: pd.DataFrame) -> pd.Series:
    # If neither CNA Team Name nor CXP Responsible Team exists or is valid, then the item shall be discarded
    no_team_available_condition = (prm_df['Check on CNA Team Name'] != "OK") & \
                                  (prm_df['Check on CXP Responsible Team'] != "OK")
    prm_df["Discard reason"] = np.where(no_team_available_condition, "Both CNA and CXP Team name not available", "")
    # If the CXP number addresses a 3pp or missing or not consistent, then the item shall be discarded
    prm_df["Discard reason"] = (prm_df["Discard reason"] + SPACE
                                + prm_df['Check on CXP Number'].map(lambda x: x if x != "OK" else "")).str.strip()
    # If the CXP number is duplicated, then the item shall be discarded
    prm_df["Discard reason"] = (prm_df["Discard reason"] + SPACE + prm_df['CXP Number duplicated']
                                .map(lambda x: "CXP number duplicated" if x == "True" else "")).str.strip()

    return prm_df["Discard reason"]


@Util.strict_types
def check_on_sg_mapping_table(sg_df: pd.DataFrame, prm_df: pd.DataFrame) -> pd.DataFrame:
    logger.info("Start check on SG Mapping Table ....")
    list_of_sg_in_prm_df = prm_df['Service Group'].to_list()
    sg_not_found_condition = ~sg_df['SG List from VA Scan'].isin(list_of_sg_in_prm_df)
    sg_missing = sg_df[sg_not_found_condition]
    logger.info("End check on SG Mapping Table")
    return sg_missing


@Util.strict_types
def summary_for_sg_mapping_table(sg_mapping_df: pd.DataFrame, sg_missing_in_prm_df: pd.DataFrame) -> list:
    summary_sg_mapping_table = [[LEFT_ALIGN.format(" "), ""],
                                [LEFT_ALIGN.format("--- Check result on SG Mapping Table ---"), ""],
                                [LEFT_ALIGN.format("SG in SG Mapping Table"), len(sg_mapping_df.index)],
                                [LEFT_ALIGN.format("Missing SG in PRM"), len(sg_missing_in_prm_df.index)]
                                ]
    return summary_sg_mapping_table


@Util.strict_types
def check_on_va_report(va_report_table_df: pd.DataFrame,
                       cxp_df: pd.DataFrame,
                       prm_df: pd.DataFrame
                       ) -> Tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame]:
    if not va_report_table_df.empty:
        # print_step("CHECKING ON VA REPORT vs CXP Table and PRM")
        logger.info("Start check on VA report ....")
        cxp_in_va_report_list = va_report_table_df.loc[va_report_table_df['CXP from Rpm Name'] != "None",
                                                       "CXP from Rpm Name"].drop_duplicates().to_list()
        # Tag in PRM the CXPs present in VA Report
        cxp_found_condition = prm_df['CXP Number'].isin(cxp_in_va_report_list)
        prm_df["CXP Number is in VA Report"] = np.where(cxp_found_condition, "YES", "NO")
        # Tag in CXP Table the CXPs present in VA Report
        cxp_found_condition = cxp_df['CXP'].isin(cxp_in_va_report_list)
        cxp_df["CXP Number is in VA Report"] = np.where(cxp_found_condition, "YES", "NO")
        # Tag in VA Report the CXPs found in PRM
        cxp_in_prm_list = prm_df['CXP Number'].drop_duplicates().to_list()
        cxp_found_condition_two = va_report_table_df['CXP from Rpm Name'].isin(cxp_in_prm_list)
        va_report_table_df["CXP number is in PRM"] = np.where(cxp_found_condition_two, "YES", "NO")
        va_report_table_df.loc[va_report_table_df['CXP from Rpm Name'] == "None", "CXP number is in PRM"] = "N/A"
        # Tag in VA Report the CXPs found in CXP Table
        cxp_in_cxp_table_list = cxp_df['CXP'].drop_duplicates().to_list()
        cxp_is_in_cxp_table_condition = va_report_table_df['CXP from Rpm Name'].isin(cxp_in_cxp_table_list)
        va_report_table_df["CXP number is in CXP Table"] = np.where(cxp_is_in_cxp_table_condition, "YES", "NO")
        va_report_table_df.loc[va_report_table_df['CXP from Rpm Name'] == "None", "CXP number is in CXP Table"] = "N/A"
        logger.info("End check on VA report")

    return va_report_table_df, cxp_df, prm_df


@Util.strict_types
def summary_for_va_report(va_report_table_df: pd.DataFrame, prm_checked_df: pd.DataFrame) -> list:
    summary_va_report = []
    if not va_report_table_df.empty:
        number_of_cxp_in_va_report = len(va_report_table_df.loc[va_report_table_df[
                                     'CXP from Rpm Name'] != "None", "CXP from Rpm Name"].drop_duplicates().to_list())
        prm_checked_df_no_duplicated = prm_checked_df[(prm_checked_df['CXP Number duplicated'] == "False")]
        prm_valid_df = get_valid_items(prm_checked_df)
        prm_discarded_df = get_discarded_items(prm_checked_df)
        prm_valid_df_no_duplicated = prm_valid_df[(prm_valid_df['CXP Number duplicated'] == "False")]
        prm_discarded_df_no_duplicated = prm_discarded_df[(prm_discarded_df['CXP Number duplicated'] == "False")]
        number_of_prm_cxp_found_in_va_report = len(prm_checked_df_no_duplicated[
                          prm_checked_df_no_duplicated['CXP Number is in VA Report'].str.contains("YES")].index)
        valid_found = len(prm_valid_df_no_duplicated[
                          prm_valid_df_no_duplicated['CXP Number is in VA Report'].str.contains("YES")].index)
        discarded_found = len(prm_discarded_df_no_duplicated[
                        prm_discarded_df_no_duplicated['CXP Number is in VA Report'].str.contains("YES")].index)
        cxp_in_va_report_missing_in_prm_df = va_report_table_df[(va_report_table_df["CXP number is in PRM"] == "NO")]
        cxp_in_va_report_missing_in_cxp_table_df = \
            va_report_table_df[(va_report_table_df["CXP number is in CXP Table"] == "NO")]

        summary_va_report = [[LEFT_ALIGN.format(" "), ""],
                             [LEFT_ALIGN.format("--- Check result on VA Report ---"), ""],
                             [LEFT_ALIGN.format("VA Report CXP number"), number_of_cxp_in_va_report],
                             [LEFT_ALIGN.format("PRM CXP number in VA Report"), number_of_prm_cxp_found_in_va_report],
                             [LEFT_ALIGN.format("PRM CXP number valid in VA Report"), valid_found],
                             [LEFT_ALIGN.format("PRM CXP number invalid in VA Report"), discarded_found],
                             [LEFT_ALIGN.format("CXP number in VA Report missing in PRM"),
                              cxp_in_va_report_missing_in_prm_df['CXP from Rpm Name'].drop_duplicates().sort_values()
                              .to_list()],
                             [LEFT_ALIGN.format("CXP number in VA Report missing in CXP Table"),
                             cxp_in_va_report_missing_in_cxp_table_df[
                                   'CXP from Rpm Name'].drop_duplicates().sort_values().to_list()]
                             ]
    return summary_va_report


@Util.strict_types
def update_cxp_and_prm_df(cxp_df: pd.DataFrame, prm_df: pd.DataFrame) -> Tuple[pd.DataFrame, pd.DataFrame]:
    # logger.info("Start check on CXP Table ......")
    # Normalize CXP Number in CXP table for check convenience
    cxp_df = check_and_normalize_cxp_number_in_table(cxp_df)
    cxp_in_prm_list = prm_df['CXP Number'].drop_duplicates().to_list()
    cxp_in_cxp_table_list = cxp_df['CXP'].drop_duplicates().to_list()
    cxp_found_condition_three = cxp_df['CXP'].isin(cxp_in_prm_list)
    cxp_df["CXP number is in PRM"] = np.where(cxp_found_condition_three, "YES", "NO")
    cxp_in_cxp_table_condition = prm_df['CXP Number'].isin(cxp_in_cxp_table_list)
    prm_df["CXP number is in CXP Table"] = np.where(cxp_in_cxp_table_condition, "YES", "NO")
    # logger.info("End check on on CXP Table ......")

    return cxp_df, prm_df


@Util.strict_types
def summary_for_cxp_table(cxp_df_param: pd.DataFrame) -> list:
    summary_cxp_table = []
    if not cxp_df_param.empty:
        number_of_cxp_in_cxp_table = len(cxp_df_param['CXP'].index)
        cxp_number_missing = len(cxp_df_param[(cxp_df_param["CXP number is in PRM"] == "NO")].index)
        summary_cxp_table = [[LEFT_ALIGN.format(" "), ""],
                             [LEFT_ALIGN.format("--- Check result on CXP Table ---"), ""],
                             [LEFT_ALIGN.format("Number of CXP in CXP Table"), number_of_cxp_in_cxp_table],
                             [LEFT_ALIGN.format("Missing CXP in PRM"), cxp_number_missing]
                            ]
    return summary_cxp_table


@Util.strict_types
def insert_new_column_to(direction: int, current_column_name: str, new_column_name: str, new_value: str,
                         df: pd.DataFrame) -> pd.DataFrame:
    if new_column_name not in df.columns:
        position = df.columns.get_loc(current_column_name) + direction
        df.insert(position, new_column_name, new_value)
    else:
        df[new_column_name] = new_value
    return df


@Util.strict_types
def create_enhanced_cxp_table_df(cxp_df: pd.DataFrame, valid_df: pd.DataFrame) -> pd.DataFrame:
    prm_valid_df = valid_df.copy()
    # print_step("UPDATING CXP TABLE with PRM VALID DATA")
    logger.info("Start creation of enhanced cxp table with PRM valid data ....")
    enhanced_cxp_table_df_returned = cxp_df.copy()
    # Set initial status for each item
    last_column_name = enhanced_cxp_table_df_returned.columns.to_list().pop()
    enhanced_cxp_table_df_returned = insert_new_column_to(RIGHT, last_column_name, 'Status', "Found in CXP Table",
                                                          enhanced_cxp_table_df_returned)
    # Insert new column 'CNA Team Name'
    enhanced_cxp_table_df_returned = insert_new_column_to(RIGHT, "CXP Resp.Team", "CXP Resp.Team from PRM",
                                                          TO_BE_FILLED, enhanced_cxp_table_df_returned)
    enhanced_cxp_table_df_returned = insert_new_column_to(RIGHT, "CXP Resp.Team from PRM", "CNA Team Name",
                                                          TO_BE_FILLED, enhanced_cxp_table_df_returned)
    # Insert new column 'Team for cve scripts'
    enhanced_cxp_table_df_returned = insert_new_column_to(RIGHT, "CNA Team Name", "Team for cve scripts", TO_BE_FILLED,
                                                          enhanced_cxp_table_df_returned)
    # For PRM valid items fill the team to use by cve scripts
    conditions = [
        prm_valid_df['Check on CXP Responsible Team'] == "OK",
        prm_valid_df['Check on CXP Responsible Team'] != "OK"
    ]
    values = [prm_valid_df['CXP Responsible Team'], prm_valid_df['CNA Team Name']]
    prm_valid_df['Team for cve scripts'] = np.select(conditions, values)

    # Update CXP in CXP Table with team info from PRM if the CXP is found also in PRM
    items_to_update_df_condition = prm_valid_df['CXP number is in CXP Table'] == "YES"
    items_to_update_df = prm_valid_df[items_to_update_df_condition]

    for prm_index in items_to_update_df.index:
        current_cxp = items_to_update_df.at[prm_index, 'CXP Number']
        for index in enhanced_cxp_table_df_returned.index:
            if enhanced_cxp_table_df_returned.at[index, 'CXP'] == current_cxp:
                enhanced_cxp_table_df_returned.at[index, 'CXP Resp.Team from PRM'] = items_to_update_df.at[
                    prm_index, 'CXP Responsible Team']
                enhanced_cxp_table_df_returned.at[index, 'CNA Team Name'] = items_to_update_df.at[
                    prm_index, 'CNA Team Name']
                enhanced_cxp_table_df_returned.at[index, 'Team for cve scripts'] = items_to_update_df.at[
                    prm_index, 'Team for cve scripts']
                enhanced_cxp_table_df_returned.at[index, 'Status'] += ' and in PRM'
                if enhanced_cxp_table_df_returned.at[index, 'CXP Resp.Team'] != \
                        enhanced_cxp_table_df_returned.at[index, 'Team for cve scripts']:
                    enhanced_cxp_table_df_returned.at[index, 'Status'] += ' and updated CXP Resp.Team'
                break

    # Add valid CXP found in PRM and not present in CXP Table
    prm_valid_df_copy = prm_valid_df.rename(
        columns={'CXP Number': 'CXP', 'CXP Responsible Team': 'CXP Resp.Team', 'CNA Number': 'Father CNA',
                 'CNA Name': 'Father CNA Name', 'CXP number is in CXP Table': 'Status'})
    prm_valid_df_copy['CXP Resp.Team from PRM'] = prm_valid_df_copy['CXP Resp.Team']
    prm_valid_df_copy.loc[prm_valid_df_copy['Status'] == "NO", 'Status']\
        = "Not found in CXP Table and added from PRM"

    prm_valid_items_to_add_condition = (prm_valid_df_copy['Status'].str.contains("Not found"))
    prm_valid_items_not_in_cxp_table_df = prm_valid_df_copy[prm_valid_items_to_add_condition]

    enhanced_cxp_table_df_returned = pd.concat([enhanced_cxp_table_df_returned, prm_valid_items_not_in_cxp_table_df],
                                               join='inner', ignore_index=True)
    enhanced_cxp_table_df_returned.reset_index()

    # Fill 'Team for cve scripts' where not filled, i.e. when CXP is present in CXP Table, but not in PRM
    enhanced_cxp_table_df_returned.loc[enhanced_cxp_table_df_returned['Team for cve scripts'] == TO_BE_FILLED,
                                       "Team for cve scripts"] = enhanced_cxp_table_df_returned['CXP Resp.Team']

    logger.info("End creation of enhanced cxp table with PRM valid data")

    return enhanced_cxp_table_df_returned

@Util.strict_types
def check_update_of_cxp_table(new_cxp_table_df: pd.DataFrame) -> Tuple[int, int]:
    num_items_added_from_prm = 0
    num_of_resp_team_updated = 0
    if not new_cxp_table_df.empty:
        status_column_values = new_cxp_table_df['Status']
        num_items_added_from_prm = get_num_occurrences(status_column_values, "added")
        num_of_resp_team_updated = get_num_occurrences(status_column_values, "updated")

    return num_items_added_from_prm, num_of_resp_team_updated


@Util.strict_types
def create_summary_for_enhanced_cxp_table(enhanced_cxp_table_df_param: pd.DataFrame, header: str = "") -> list:
    summary_for_update = [[LEFT_ALIGN.format(" "), ""], [LEFT_ALIGN.format(header), ""]]
    if not enhanced_cxp_table_df_param.empty:
        status_column_values = enhanced_cxp_table_df_param['Status']
        cxp_added_from_prm, cxp_resp_team_updated = check_update_of_cxp_table(enhanced_cxp_table_df_param)
        if (cxp_added_from_prm > 0) or (cxp_resp_team_updated > 0):
            cxp_in_previous_cxp_table = get_num_occurrences(status_column_values, "Found in CXP Table")
            number_of_cxp_in_enhanced_cxp_table = len(enhanced_cxp_table_df_param['CXP'].index)
            cxp_number_valid = \
                len(enhanced_cxp_table_df_param[enhanced_cxp_table_df_param['Check on CXP Number'] == "OK"].index)
            cxp_number_wrong = \
                len(enhanced_cxp_table_df_param[enhanced_cxp_table_df_param['Check on CXP Number'] != "OK"].index)
            summary_for_update = summary_for_update + [
                [LEFT_ALIGN.format("CXP in current CXP Table"), cxp_in_previous_cxp_table],
                [LEFT_ALIGN.format("CXP to be added from PRM "), cxp_added_from_prm],
                [LEFT_ALIGN.format("CXP in updated CXP Table "), number_of_cxp_in_enhanced_cxp_table],
                [LEFT_ALIGN.format(" "), ""],
                [LEFT_ALIGN.format("Valid CXP "), cxp_number_valid],
                [LEFT_ALIGN.format("Invalid CXP "), cxp_number_wrong],
                [LEFT_ALIGN.format(" "), ""],
                [LEFT_ALIGN.format("CXP Resp.Team updated from PRM"), cxp_resp_team_updated]
            ]
        else:
            summary_for_update = summary_for_update + FRAME_NO_CHANGES_TO_APPLY

    return summary_for_update


@Util.strict_types
def summary_for_prm(prm_checked_df: pd.DataFrame) -> list:
    discarded_df = get_discarded_items(prm_checked_df)
    discard_reason_column_values = discarded_df['Discard reason']
    number_of_no_team_available = \
        get_num_occurrences(discard_reason_column_values, "Both CNA and CXP Team name not available")
    number_of_3pp = get_num_occurrences(discard_reason_column_values, "3pp")
    number_of_invalid_cxp = get_num_occurrences(discard_reason_column_values, "CXP number not consistent")
    number_of_missing_cxp = get_num_occurrences(discard_reason_column_values, "Missing CXP Number")
    number_of_duplicated_cxp = get_num_occurrences(discard_reason_column_values, "CXP number duplicated")

    summary_prm = [[LEFT_ALIGN.format("PRM total items:"), len(prm_checked_df.index)],
                   [LEFT_ALIGN.format(" "), ""],
                   [LEFT_ALIGN.format("Number of PRM valid items:"), len(get_valid_items(prm_checked_df).index)],
                   [LEFT_ALIGN.format("Number of PRM discarded items:"), len(discarded_df.index)],
                   [LEFT_ALIGN.format("Number of PRM discarded items with issues:"),
                    len(get_discarded_items_with_issues(discarded_df).index)],
                   [LEFT_ALIGN.format(" "), ""],
                   [LEFT_ALIGN.format("----- List of discard reason ----"), ""],
                   [LEFT_ALIGN.format("CNA and CXP Team name not available"), number_of_no_team_available],
                   [LEFT_ALIGN.format("CXP number is a 3pp FOSS/Commercial"), number_of_3pp],
                   [LEFT_ALIGN.format("CXP number not consistent"), number_of_invalid_cxp],
                   [LEFT_ALIGN.format("CXP number missing"), number_of_missing_cxp],
                   [LEFT_ALIGN.format("CXP number duplicated"), number_of_duplicated_cxp]
                   ]
    return summary_prm


@Util.strict_types
def write_prm_report_file(suffix: str,
                          summary: pd.DataFrame,
                          prm_df: pd.DataFrame,
                          cxp_table: pd.DataFrame,
                          sg_missing: pd.DataFrame  | None = None,
                          va_report:  pd.DataFrame | None = None,
                          forecast_cxp_table: pd.DataFrame | None = None):

    sg_missing = pd.DataFrame() if sg_missing is None else sg_missing
    va_report = pd.DataFrame() if va_report is None else va_report
    forecast_cxp_table = pd.DataFrame() if forecast_cxp_table is None else forecast_cxp_table

    prm_discarded_df = get_discarded_items(prm_df)
    df_list = [summary, get_valid_items(prm_df), prm_discarded_df, get_discarded_items_with_issues(prm_discarded_df),
               sg_missing, va_report, cxp_table, forecast_cxp_table]
    sheet_name_list = ['Summary', 'PRM valid items', 'PRM discarded items', 'PRM issues', 'Missing SG',
                       'VA Report checked', 'CXP Table checked', 'CXP Table forecast']
    sheet_header_list = [False, True, True, True, True, True, True, True]

    Util.write_sheets_to_excel(build_filename(prm_report, suffix), df_list, sheet_name_list, sheet_header_list)
    logger.info("Generated PRM Excel report file: {}".format(build_filename(prm_report, suffix)))


@Util.strict_types
def write_prm_issues_file(suffix: str, prm_issues_df: pd.DataFrame):
    prm_issues_filename = build_filename(prm_issues, suffix)
    Util.write_sheet_to_excel(prm_issues_filename, prm_issues_df, 'PRM issues')
    logger.info("Generated PRM table with invalid items: {} ......".format(prm_issues_filename))


@Util.strict_types
def build_filename(path: str, suffix: str = "") -> str:
    root, extension = os.path.splitext(path)
    if len(suffix) > 0:
        suffix = "_" + suffix
    return root + suffix + extension


@Util.strict_types
def write_enhanced_cxp_table_file(new_cxp_table_df: pd.DataFrame) -> pd.DataFrame:
    if not new_cxp_table_df.empty:
        logger.info("Enhanced CXP Table generation in progress ...")
        # drop useless columns for cve scripts
        new_cxp_table_df.drop(['CXP Resp.Team', 'CXP Resp.Team from PRM', 'CNA Team Name', 'Status',
                               'Check on CXP Number'], inplace=True, axis=1)
        if 'CXP Number is in VA Report' in new_cxp_table_df.columns:
            new_cxp_table_df.drop('CXP Number is in VA Report', inplace=True, axis=1)
        # rename column for convenience of cve scripts
        new_cxp_table_df.rename(columns={'Team for cve scripts': 'CXP Resp.Team'}, inplace=True)
        new_cxp_table_filename = \
            os.path.join(top_dir, Util.get_file_from_dictionary(dict_from_config_file, 'cxp_table'))
        new_cxp_table_df.to_csv(new_cxp_table_filename, index=False)
        logger.info("Enhanced CXP Table generated")

    return new_cxp_table_df


@Util.strict_types
def load_input_tables() -> Tuple[Union[pd.DataFrame, None], Union[pd.DataFrame, None], Union[pd.DataFrame, None],
                                 pd.DataFrame]:
    logger.info("Loading configuration from properties file: {} ....".format(config_property_file))

    # Load Team Inventory
    team_inv_table_file = Util.get_file_from_dictionary(dict_from_config_file, 'team_inv_table')
    team_inventory_df = Util.get_df_from_spreadsheet_file(team_inv_table_file)
    # Load CXP Table
    cxp_table_file = os.path.join(top_dir, Util.get_file_from_dictionary(dict_from_config_file, 'cxp_table'))
    cxp_table_original_df = Util.get_df_from_spreadsheet_file(cxp_table_file)
    # Load SG Mapping Table
    sg_mapping_table_file = os.path.join(top_dir,
                                         Util.get_file_from_dictionary(dict_from_config_file, 'sg_mapping_table'))
    sg_mapping_df = Util.get_df_from_spreadsheet_file(sg_mapping_table_file)

    # Load VA report files
    logger.info("=== Start creation of VA Reports table....")
    va_report_table_df = None
    if os.path.exists(va_report_filename) or os.path.exists(va_report_base_image_filename):
        va_report_table_df = get_cxp_df_from_va_reports_filtered_by_severity(dict_from_config_file['default_severities'])
    if va_report_table_df is None:
        logger.info(" VA report files not found")
        va_report_table_df = pd.DataFrame()
    logger.info("=== End creation of VA Reports table")

    return team_inventory_df, cxp_table_original_df, sg_mapping_df, va_report_table_df


@Util.strict_types
def check_prm(prm_df: pd.DataFrame, ti_df: pd.DataFrame) -> pd.DataFrame:
    logger.info("Start check on PRM dataframe ....")
    prm_df_checked = prm_df.copy()
    # Normalization of all NaN occurrences (float) into null string to avoid problems with type checks
    prm_df_checked.fillna("", inplace=True)
    # Check if "CXP Responsible Team" values are consistent with respect to "Team" in Team Inventory table
    available_teams = ti_df['Team'].to_list()
    prm_df_checked['Check on CXP Responsible Team'] = \
        prm_df_checked['CXP Responsible Team'].apply(lambda team: check_team(team, available_teams))
    # Check if "CNA Team Name" values are consistent with respect to "Team" in Team Inventory table
    prm_df_checked['Check on CNA Team Name'] = \
        prm_df_checked['CNA Team Name'].apply(lambda team: check_team(team, available_teams))
    # Check if CXP number is consistent
    prm_df_checked['Check on CXP Number'] = prm_df_checked['CXP Number'].apply(check_cxp_number)
    # Normalization of CXP number checked OK
    prm_df_checked.loc[prm_df_checked['Check on CXP Number'] == "OK", "CXP Number"] = \
        prm_df_checked['CXP Number'].apply(normalize_cxp_number)
    # Check if CXP number is duplicated
    prm_df_checked['CXP Number duplicated'] = prm_df_checked[
            (prm_df_checked['Check on CXP Number'] == "OK")].duplicated(subset='CXP Number', keep='first').astype(str)
    prm_df_checked.loc[prm_df_checked['Check on CXP Number'] != "OK", 'CXP Number duplicated'] = "n/a"
    # Build column "Discard reason" with all reasons of discard detected
    prm_df_checked["Discard reason"] = add_discard_reason_column(prm_df_checked)
    logger.info("End check on PRM dataframe")

    return prm_df_checked


@Util.strict_types
def get_discarded_items(prm_df: pd.DataFrame) -> pd.DataFrame:
    return prm_df[(prm_df['Discard reason'] != "")]


@Util.strict_types
def get_discarded_items_with_issues(discarded_df: pd.DataFrame) -> pd.DataFrame:
    issue_condition = ~discarded_df['Discard reason'].str.contains("3pp")
    return discarded_df[issue_condition]


@Util.strict_types
def get_valid_items(prm_df: pd.DataFrame) -> pd.DataFrame:
    return prm_df[(prm_df['Discard reason'] == "")]


@Util.strict_types
def extract_cxp_from_rpm(df: pd.DataFrame) -> pd.DataFrame:
    df['CXP from Rpm Name'] = df['Rpm Package'].apply(lambda x: Util.extract_string_by_regex(x, EXTRACT_RPM_CXP_REGEX))
    return df


@Util.strict_types
def explode_rpm_package_field(table: pd.DataFrame) -> pd.DataFrame:
    logger.debug("Expand rows when 'RPM Package' are hashtag separated")
    table["Rpm Package"] = table["Rpm Package"].str.split('#')
    hashtag_exploded_table = table.explode(["Rpm Package"], ignore_index=True)

    logger.debug("Expand rows when 'RPM Package' are pipes separated")
    hashtag_exploded_table["Rpm Package"] = hashtag_exploded_table["Rpm Package"].str.split("|")
    pipe_exploded_table = hashtag_exploded_table.explode(["Rpm Package"], ignore_index=True)

    logger.debug("Expand rows when 'RPM Package' are space separated")
    return Util.explode_rows_with_separator(pipe_exploded_table, 'Rpm Package', ' ')


@Util.strict_types
def add_extracted_cxp_from_rpm_name(df: pd.DataFrame, path_to_rpm_associations: dict) -> pd.DataFrame:
    for val in path_to_rpm_associations.values():
        cxp = Util.extract_string_by_regex(val, EXTRACT_RPM_CXP_REGEX)
        new_row = pd.DataFrame({'Rpm Package': val,
                                'CXP from Rpm Name': cxp}, index=[0])
        df = pd.concat([df, new_row])
    return df


@Util.strict_types
def extract_cxp_from_va_report_filtered_by_severity(filename: str, severity_list: list) -> pd.DataFrame:
    va_df = Util.get_df_from_spreadsheet_file(filename)
    if va_df is None:
        return pd.DataFrame()

    # Extract entry with selected severity
    va_df = Util.filter_table_by(va_df, 'Severity', severity_list)

    va_df = va_df[['Rpm Package']]
    va_df.drop_duplicates(inplace=True)

    va_df = explode_rpm_package_field(va_df)

    va_df = extract_cxp_from_rpm(va_df)
    va_df = va_df[va_df['CXP from Rpm Name'] != 'None']
    va_df.drop_duplicates('CXP from Rpm Name', inplace=True)

    va_df = add_extracted_cxp_from_rpm_name(va_df, dict_from_path_2_rpm_file)
    va_df.drop_duplicates('CXP from Rpm Name', inplace=True)

    return va_df


@Util.strict_types
def get_cxp_df_from_va_reports_filtered_by_severity(severity_list: list) -> pd.DataFrame:
    va_df = extract_cxp_from_va_report_filtered_by_severity(va_report_filename, severity_list)
    logger.info(f"Number of CXP in '{va_report_filename}': {len(va_df.index)}")

    va_base_df = extract_cxp_from_va_report_filtered_by_severity(va_report_base_image_filename, severity_list)
    logger.info(f"Number of CXP in '{va_report_base_image_filename}': {len(va_base_df.index)}")

    df = pd.concat([va_df, va_base_df])
    df.drop_duplicates('CXP from Rpm Name', inplace=True)
    logger.info(f"Total number of collected unique CXP: {len(df.index)}")

    return df


def main():
    """
    This function is invoked when launched as standalone script.
    Check data coming from Product Release Matrix and produces both a report and a table with valid items
    for future consuming by cve scripts.
    See header file for further information.
    """
    print_step("SETUP")
    # Check pandas and python version
    start_time = time()
    current_date_time = datetime.today().strftime("%Y-%m-%d_%H_%M_%S")
    generate_issues = True
    logger.info("Script: {}".format(os.path.basename(__file__)))
    logger.info("Used pandas version: {}".format(pd.__version__))
    logger.info("Used python version: {}.{}.{}".format(sys.version_info.major, sys.version_info.minor,
                                                       sys.version_info.micro))
    # Check and create output folder for report
    Util.create_working_dir_and_remove_tree_if_exists('generated_support_tables', False)

    print_step("CHECK AND APPLY PRM DATA")
    if check_and_apply_prm_data(update_cxp_table_with_prm_data, True, current_date_time, generate_issues):
        end_time = time()
        execution_time = end_time - start_time
        logger.info(Util.colour_text(Util.MyColours.GREEN, f'Execution time: {execution_time: .2f}s'))
    else:
        logger.error(Util.colour_text(Util.MyColours.RED, 'something went wrong while checking....exiting'))
        sys.exit(1)


if __name__ == "__main__":
    main()
